import 'babel-polyfill'

const { MutationObserver } = window

// Query string for elements that can be validated.
const fieldTags = 'input, textarea, select'
const attributes = [
  'required',
  'minlength',
  'maxlength',
  'pattern',
  'max',
  'min',
  'step',
  'type'
]

/**
 * extractValidity - Extracts the ValidityState information from a given
 * object into an object suitable for manipulation.
 *
 * @param  {HTMLElement} el A DOM element containing a ValidityState object.
 * @return {object}         A non-read-only object mimicing the ValidityState
 *                          object for the given element.
 */
function extractValidity(el) {
  const validity = el.validity

  // VaidityState.tooShort/minlength polyfill for older browsers.
  let tooShort = validity.tooShort
  let valid = validity.valid
  if (el.getAttribute) {
    const minlength = el.getAttribute('minlength')
    if (minlength && typeof tooShort === 'undefined') {
      tooShort = el.value.length < minlength
      if (tooShort) {
        valid = false
        let msg = `Please lengthen this text to ${minlength} characters or `
        msg += `more (you are currently using ${el.value.length} characters).`
        el.setCustomValidity(msg)
      } else {
        el.setCustomValidity('')
      }
    }
  }

  return {
    badInput: validity.badInput,
    customError: validity.customError,
    patternMismatch: validity.patternMismatch,
    rangeOverflow: validity.rangeOverflow,
    rangeUnderflow: validity.rangeUnderflow,
    stepMismatch: validity.stepMismatch,
    tooLong: validity.tooLong,
    tooShort,
    typeMismatch: validity.typeMismatch,
    valid,
    valueMissing: validity.valueMissing,
  }
}

/**
 * createField - Creates a field object with the given element and its
 * extracted ValidityState or an empty validity object if no element is given.
 *
 * @param  {HTMLElement|Object} el = { validity: {} } A DOM element or an empty
 *                                                    validity state object.
 * @return {Object}                                   A field object.
 */
function createField (el = { validity: {} }) {
  if (el.hasAttribute) {
    return Object.assign({ el, wasFocused: false }, extractValidity(el))
  } else {
    return Object.assign({ wasFocused: false }, extractValidity(el))
  }
}

// Extracts the values of an elements id and name.
const getIds = el => [el.getAttribute('id'), el.getAttribute('name')]

// The VueForm class used as a Vue.js plugin and to model a form that is to be
// validated.
export default class VueForm {

  /**
   * constructor - Create a new VueForm instance which models a HTML form that
   * is to be validated.
   *
   * @param  {Object}   options = {} An options object used to configure the
   *                                 VueForm instance that will be created.
   * @return {VueForm}               A VueForm instance.
   */
  constructor (options = {}) {
    // Option defaults.
    const defaults = {
      wasFocusedClass: 'wasFocused',
      wasSubmittedClass: 'wasSubmitted',
      noValidate: true,
      requiredGroups: [],
      ignoredFields: [],
      customValidators: {}
    }
    Object.assign(this, defaults, options)

    // The $cache is used so that VueForm can update its state without
    // triggering needless reactive updates.
    this.$cache = {
      fields: {},
      invalidFields: [],
      wasSubmitted: false,
      isInvalid: false,
      isValid: true
    }

    // The state object is what end users should base reactive updates on.
    this.state = Object.assign({}, this.$cache)
  }

  /**
   * @static install - Called when used in a Vue.js application to set up the
   * $newVueForm function and make the v-form and v-custom-validator directives
   * available.
   *
   * @param  {type} Vue description
   * @return {type}     description
   */
  static install (Vue) {
    // A function added to the Vue object to allow end users to create a
    // new VueForm instance without having to directly import VueForm.
    Vue.prototype.$newVueForm = options => new VueForm(options)

    /**
     * inserted - Called when the form element containing the v-form directive
     * is first inserted into the document and is used to set up the VueForm
     * instance with the form element.
     *
     * @param  {HTMLElement} el      The form element containing the v-form
     *                               directive.
     * @param  {Object}      context The context object associated with the
     *                               inserted directive event. Contains the
     *                               VueForm instance that is passed to the
     *                               v-form directive. i.e. v-form="myForm".
     */
    function inserted (el, context) {
      const formInstance = context.value
      if (formInstance instanceof VueForm && !formInstance.el) {
        formInstance.registerFormElement(el, Vue)
      }
    }

    // Stop the forms MutationObserver instance from receiving notifications
    // of DOM mutations when the directive is unbound from the element. Not
    // sure if this cleanup is really necessary, but better safe than sorry I
    // guess.
    const unbind = (el, context) => {
      const formInstance = context.value
      if (formInstance instanceof VueForm && formInstance.observer) {
        formInstance.observer.disconnect()
      }
    }

    // Register the v-form directive.
    Vue.directive('form', { inserted, componentUpdated: inserted, unbind })

    // Register the v-custom-validator directive.
    Vue.directive('custom-validator', (el, context) => {
      const [formInstance, customValidator] = context.value
      if (formInstance instanceof VueForm) {
        for (const id of getIds(el)) {
          if (id) {
            formInstance.customValidators[id] = customValidator
          }
        }
      }
    })
  }

  /**
   * updateState - Merges the $cache containing the validity state of the form
   * with the public facing state object without causing needless reactive
   * updates.
   */
  updateState () {
    const { $cache, state } = this
    const update = () => (this.state = Object.assign({}, state, $cache))
    if (this.Vue) {
      // Using the nextTick function to prevent sending reactive updates before
      // Vue has finished updating.
      this.Vue.nextTick(() => update())
    } else {
      update()
    }
  }

  /**
   * updateOptions - Updates the VueForm instance configuration and re-evaluates
   * the validity state of all tracked fields within the form.
   *
   * @param  {type} options The options object used to configure the VueForm
   *                        instance.
   */
  updateOptions (options) {
    // Set the options.
    Object.assign(this, options)

    // Re-evaluate the validity of all tracked fields.
    if (this.el) {
      this.registerFieldElements(this.el.querySelectorAll(fieldTags), 'added')
      this.updateState()
    }
  }

  /**
   * registerFormElement - Configures the current VueForm instance with the
   * given form element and creates a MutationObserver to monitor when fields
   * are added to the form, removed from the form, or have their attributes
   * updated.
   *
   * @param  {HTMLElement} el  The form element containing the v-form directive.
   * @param  {Vue}         Vue The Vue object which installed VueForm.
   */
  registerFormElement (el, Vue) {
    this.Vue = Vue
    this.el = el
    this.el.noValidate = this.noValidate

    // Update the forms $wasSubmitted state and apply the appropriate CSS
    // class when the forms submit event is triggered.
    this.el.addEventListener('submit', () => {
      this.$cache.wasSubmitted = true
      this.el.classList.add(this.wasSubmittedClass)
      this.updateState()
    })

    // Update the form and child field state and remove any corresponding
    // CSS classes when the forms reset event is triggered.
    this.el.addEventListener('reset', () => {
      this.$cache.wasSubmitted = false
      this.el.classList.remove(this.wasSubmittedClass)

      // Reset $wasFocused property and remove the corresponding class
      // from each child node.
      // FIXME update for batched updates
      // for (const id of Object.keys(this)) {
      //   Vue.set(this[id], '$wasFocused', false)
      //   this[id].el.classList.remove(this.$wasFocusedClass)
      //   Object.assign(this[id], extractValidity(this[id].$el))
      //   this.updateFormValidity(id)
      // }
    })

    // Add all the qualifying form control elements to the form as field
    // objects.
    this.registerFieldElements(el.querySelectorAll(fieldTags), 'added')
    this.updateState()

    // Create a MutationObserver on the form element that will receive
    // mutations.
    this.observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        let { removedNodes, addedNodes, type, attributeName } = mutation

        // Determine relevant root DOM node.
        const rootNode = removedNodes[0] || addedNodes[0] || mutation.target

        // If the mutation has a rootNode, the root node is a normal HTML
        // element (it has a hasAttribute property), and it's either not a
        // attribute mutation or the attribute is whitelisted, register
        // the qualifying rootNode and/or child nodes.
        const isWhitelisted = attributes.indexOf(attributeName) !== -1
        const isAllowed = type !== 'attributes' || isWhitelisted
        if (rootNode && rootNode.hasAttribute && isAllowed) {
          // Collect all form field child nodes.
          const nodes = [...rootNode.querySelectorAll(fieldTags)]

          // If root node is a form field, add it to the node list.
          if (fieldTags.indexOf(rootNode.tagName.toLowerCase()) !== -1) {
            nodes.push(rootNode)
          }

          // If it's a childList mutation, determine if it's removing or
          // adding nodes.
          if (removedNodes && removedNodes.length) {
            type = 'removed'
          } else if (addedNodes && addedNodes.length) {
            type = 'added'
          }

          // Add or remove fields from the VueForm instance.
          this.registerFieldElements(nodes, type)
        }
      }
    })

    // Configure the form MutationObserver to watch for all mustations on
    // element attributes and childNodes.
    const options = { attributes: true, subtree: true, childList: true }
    this.observer.observe(el, options)
  }

  // TODO doc
  /**
   * completeValidtion - description
   *
   * @param  {type} evt description
   * @return {type}     description
   */
  completeValidtion (evt) {
    return new Promise(resolve => {
      const update = (id, resolve, hasCustomValidatorResult, result) => {
        if (hasCustomValidatorResult) {
          this.setCustomValidity(id, result)
        }
        this.updateFormValidity(id)
        resolve()
      }
      for (const id of getIds(evt.target)) {
        if (id) {
          const customValidator = this.customValidators[id]
          if (customValidator) {
            const response = customValidator(evt)
            if (response && response.then) {
              response.then(result => update(id, resolve, true, result))
            } else {
              update(id, resolve, true, response)
            }
          } else {
            update(id, resolve)
          }
        }
      }
    })
  }

  /**
   * addEventListener - Adds an event listener on the given type so that the
   * elements validity state can be updated within the VueForm instance.
   *
   * @param  {HTMLElement} el The element to add the event listener.
   * @param  {String}      eventType The event type. i.e. 'change' or 'input'.
   */
  addEventListener (el, eventType) {
    el.addEventListener(eventType, evt => {
      // setTimeout necessary here to keep webkit/ie in sync.
      setTimeout(() => {
        const id = evt.target.getAttribute('id')
        const name = evt.target.getAttribute('name')
        if (id) {
          Object.assign(this.$cache.fields[id], extractValidity(evt.target))
        }
        if (name) {
          this.updateNamedValidity(evt.target)
        }
        this.completeValidtion(evt).then(() => this.updateState())
      }, 0)
    })
  }

  /**
   * registerFieldElements - description
   *
   * @param  {type} nodes description
   * @param  {type} type  description
   * @return {type}       description
   */
  registerFieldElements (nodes, type) {
    const promises = []

    // TODO comment
    for (const node of nodes) {
      const id = node.getAttribute('id')
      const name = node.getAttribute('name')
      const notIgnoredId = this.ignoredFields.indexOf(id) === -1
      const notIgnoredName = this.ignoredFields.indexOf(name) === -1

      if (notIgnoredId && notIgnoredName) {
        const { $cache } = this
        const hasIdField = id && $cache.fields[id]
        const hasNameField = name && $cache.fields[name]

        // TODO comment
        if (type === 'added') {
          if (id) {
            // Create the field object and extract its validity state.
            $cache.fields[id] = createField(node)

            // Add wasFocused class to element when focus event is triggered.
            node.addEventListener('focus', ({ target }) => {
              $cache.fields[id].wasFocused = true
              target.classList.add(this.wasFocusedClass)
              this.updateState()
            })
          }

          // On change or input events, update the field and form validity
          // state.
          const inputType = node.getAttribute('type')
          const isCheckable = ['radio', 'checkbox'].indexOf(inputType) !== -1
          const isSelect = node.tagName.toLowerCase() === 'select'
          const eventType = isSelect || isCheckable ? 'change' : 'input'
          this.addEventListener(node, eventType)

        } else if (hasIdField && type === 'attributes') {
          // Update the fields validity state because it may have
          // changed due to an updated attribute on its element.
          Object.assign($cache.fields[id], extractValidity(node))
        } else if ((hasIdField || hasNameField) && type === 'removed') {
          // If the field has been removed, set it to a new empty field
          // so that VueForm will not consider it invalid.
          $cache.fields[id || name] = createField()
        }

        // TODO comment
        if (name) {
          this.updateNamedValidity(node)
        }

        promises.push(this.completeValidtion({ target: node }))
      }
    }

    // TODO comment
    Promise.all(promises).then(() => this.updateState())
  }

  // TODO doc
  /**
   * get - description
   *
   * @param  {type} id description
   * @return {type}    description
   */
  get (id) {
    if (!this.state.fields[id]) {
      this.state.fields[id] = createField()
    }
    return this.state.fields[id]
  }

  /**
   * setCustomValidity - A wrapper for HTML5s setCustomValidity function so
   * that the end user can trigger a custom error without an error message,
   * the custom error message is accessible through the form object, and the
   * overall form validity is updated.
   *
   * @param {string}          id      The identifier for the field you wish to
   *                                  set the validity for.
   * @param {boolean|string}  invalid Whether the field is invalid (true), or
   *                                  not (false), or the custom error message
   *                                  for an invalid field.
   */
  setCustomValidity (id, invalid) {
    const { $cache } = this
    if ($cache.fields[id]) {
      const isBoolean = typeof invalid === 'boolean'
      const isString = typeof invalid === 'string'
      const isNonEmptyString = isString && invalid.length > 0
      if (invalid && (isBoolean || isNonEmptyString)) {
        if (isNonEmptyString) {
          $cache.fields[id].customMessage = invalid
        } else {
          invalid = 'Error'
        }
      } else {
        $cache.fields[id].customMessage = null
        invalid = ''
      }
      if ($cache.fields[id].el) {
        const el = $cache.fields[id].el
        el.setCustomValidity(invalid)
        Object.assign($cache.fields[id], extractValidity(el))
      } else {
        $cache.fields[id].customError = invalid !== ''
        $cache.fields[id].valid = $cache.fields[id].valid && invalid === ''
      }
    }
  }

  /**
   * updateFormValidity - Updates the overall validity of the form based on
   * the existing validity state of its fields and the updated validity state
   * of the given field.
   *
   * @param {string} id The identifier for the field whose validity state has
   *                    updated and has consequently triggered the update of
   *                    the overall forms validity.
   */
  updateFormValidity (id) {
    const index = this.$cache.invalidFields.indexOf(id)
    const field = this.$cache.fields[id]
    const valid = field && (field.valid || field.valid === undefined)
    if (valid && index !== -1) {
      this.$cache.invalidFields.splice(index, 1)
      if (this.$cache.invalidFields.length === 0) {
        this.$cache.isValid = true
        this.$cache.isInvalid = false
      }
    } else if (!valid && index === -1) {
      this.$cache.isValid = false
      this.$cache.isInvalid = true
      this.$cache.invalidFields.push(id)
    }
  }

  /**
   * $updateNamedValidity - For the use case of requiring a value for a set
   * of checkboxes or radio buttons with the same name, VueForm provides the
   * validity state of the overall group using the name as the identifier.
   * This function updates this validity state.
   *
   * @param {HTMLElement} el  The DOM element that may trigger an update to
   *                          the validity of the named group.
   */
  updateNamedValidity (el) {
    const name = el.getAttribute('name')
    const { fields } = this.$cache
    if (name && (this.requiredGroups.indexOf(name) !== -1 || fields[name])) {
      // Set the validity state of the named group.
      const valueMissing = this.getNamedValueMissing(name)
      let validity = { valueMissing, valid: !valueMissing }
      if (valueMissing === undefined) {
        validity.valid = undefined
      }
      fields[name] = Object.assign({}, fields[name], validity)
    }
  }

  /**
   * getNamedValueMissing -
   *
   * @param  {type} name description
   * @return {type}      description
   */
  getNamedValueMissing (name) {
    const elements = [...this.el.querySelectorAll(`[name=${name}]`)]
    for (const el of elements) {
      const isCheckable = ['radio', 'checkbox'].indexOf(el.type) !== -1
      if ((isCheckable && el.checked) || (!isCheckable && el.value)) {
        return false
      } else if (elements.indexOf(el) === elements.length - 1) {
        return true
      }
    }
    return undefined
  }

}
