(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('babel-polyfill')) :
  typeof define === 'function' && define.amd ? define(['babel-polyfill'], factory) :
  (global.VueForm = factory(global.babelPolyfill));
}(this, (function (babelPolyfill) { 'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var _window = window;
var MutationObserver = _window.MutationObserver;

// Query string for elements that can be validated.

var fieldTags = 'input, textarea, select';
var attributes = ['required', 'minlength', 'maxlength', 'pattern', 'max', 'min', 'step', 'type'];

/**
 * extractValidity - Extracts the ValidityState information from a given
 * object into an object suitable for manipulation.
 *
 * @param  {HTMLElement} el A DOM element containing a ValidityState object.
 * @return {object}         A non-read-only object mimicing the ValidityState
 *                          object for the given element.
 */
function extractValidity(el) {
  var validity = el.validity;

  // VaidityState.tooShort/minlength polyfill for older browsers.
  var tooShort = validity.tooShort;
  var valid = validity.valid;
  if (el.getAttribute) {
    var minlength = el.getAttribute('minlength');
    if (minlength && typeof tooShort === 'undefined') {
      tooShort = el.value.length < minlength;
      if (tooShort) {
        valid = false;
        var msg = 'Please lengthen this text to ' + minlength + ' characters or ';
        msg += 'more (you are currently using ' + el.value.length + ' characters).';
        el.setCustomValidity(msg);
      } else {
        el.setCustomValidity('');
      }
    }
  }

  return {
    badInput: validity.badInput,
    customError: validity.customError,
    patternMismatch: validity.patternMismatch,
    rangeOverflow: validity.rangeOverflow,
    rangeUnderflow: validity.rangeUnderflow,
    stepMismatch: validity.stepMismatch,
    tooLong: validity.tooLong,
    tooShort: tooShort,
    typeMismatch: validity.typeMismatch,
    valid: valid,
    valueMissing: validity.valueMissing
  };
}

/**
 * createField - Creates a field object with the given element and its
 * extracted ValidityState or an empty validity object if no element is given.
 *
 * @param  {HTMLElement|Object} el = { validity: {} } A DOM element or an empty
 *                                                    validity state object.
 * @return {Object}                                   A field object.
 */
function createField() {
  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { validity: {} };

  if (el.hasAttribute) {
    return Object.assign({ el: el, wasFocused: false }, extractValidity(el));
  } else {
    return Object.assign({ wasFocused: false }, extractValidity(el));
  }
}

// Extracts the values of an elements id and name.
var getIds = function getIds(el) {
  return [el.getAttribute('id'), el.getAttribute('name')];
};

// The VueForm class used as a Vue.js plugin and to model a form that is to be
// validated.

var VueForm = function () {

  /**
   * constructor - Create a new VueForm instance which models a HTML form that
   * is to be validated.
   *
   * @param  {Object}   options = {} An options object used to configure the
   *                                 VueForm instance that will be created.
   * @return {VueForm}               A VueForm instance.
   */
  function VueForm() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VueForm);

    // Option defaults.
    var defaults$$1 = {
      wasFocusedClass: 'wasFocused',
      wasSubmittedClass: 'wasSubmitted',
      noValidate: true,
      requiredGroups: [],
      ignoredFields: [],
      customValidators: {}
    };
    Object.assign(this, defaults$$1, options);

    // The $cache is used so that VueForm can update its state without
    // triggering needless reactive updates.
    this.$cache = {
      fields: {},
      invalidFields: [],
      wasSubmitted: false,
      isInvalid: false,
      isValid: true
    };

    // The state object is what end users should base reactive updates on.
    this.state = Object.assign({}, this.$cache);
  }

  /**
   * @static install - Called when used in a Vue.js application to set up the
   * $newVueForm function and make the v-form and v-custom-validator directives
   * available.
   *
   * @param  {type} Vue description
   * @return {type}     description
   */


  createClass(VueForm, [{
    key: 'updateState',


    /**
     * updateState - Merges the $cache containing the validity state of the form
     * with the public facing state object without causing needless reactive
     * updates.
     */
    value: function updateState() {
      var _this = this;

      var $cache = this.$cache,
          state = this.state;

      var update = function update() {
        return _this.state = Object.assign({}, state, $cache);
      };
      if (this.Vue) {
        // Using the nextTick function to prevent sending reactive updates before
        // Vue has finished updating.
        this.Vue.nextTick(function () {
          return update();
        });
      } else {
        update();
      }
    }

    /**
     * updateOptions - Updates the VueForm instance configuration and re-evaluates
     * the validity state of all tracked fields within the form.
     *
     * @param  {type} options The options object used to configure the VueForm
     *                        instance.
     */

  }, {
    key: 'updateOptions',
    value: function updateOptions(options) {
      // Set the options.
      Object.assign(this, options);

      // Re-evaluate the validity of all tracked fields.
      if (this.el) {
        this.registerFieldElements(this.el.querySelectorAll(fieldTags), 'added');
        this.updateState();
      }
    }

    /**
     * registerFormElement - Configures the current VueForm instance with the
     * given form element and creates a MutationObserver to monitor when fields
     * are added to the form, removed from the form, or have their attributes
     * updated.
     *
     * @param  {HTMLElement} el  The form element containing the v-form directive.
     * @param  {Vue}         Vue The Vue object which installed VueForm.
     */

  }, {
    key: 'registerFormElement',
    value: function registerFormElement(el, Vue) {
      var _this2 = this;

      this.Vue = Vue;
      this.el = el;
      this.el.noValidate = this.noValidate;

      // Update the forms $wasSubmitted state and apply the appropriate CSS
      // class when the forms submit event is triggered.
      this.el.addEventListener('submit', function () {
        _this2.$cache.wasSubmitted = true;
        _this2.el.classList.add(_this2.wasSubmittedClass);
        _this2.updateState();
      });

      // Update the form and child field state and remove any corresponding
      // CSS classes when the forms reset event is triggered.
      this.el.addEventListener('reset', function () {
        _this2.$cache.wasSubmitted = false;
        _this2.el.classList.remove(_this2.wasSubmittedClass);

        // Reset $wasFocused property and remove the corresponding class
        // from each child node.
        // FIXME update for batched updates
        // for (const id of Object.keys(this)) {
        //   Vue.set(this[id], '$wasFocused', false)
        //   this[id].el.classList.remove(this.$wasFocusedClass)
        //   Object.assign(this[id], extractValidity(this[id].$el))
        //   this.updateFormValidity(id)
        // }
      });

      // Add all the qualifying form control elements to the form as field
      // objects.
      this.registerFieldElements(el.querySelectorAll(fieldTags), 'added');
      this.updateState();

      // Create a MutationObserver on the form element that will receive
      // mutations.
      this.observer = new MutationObserver(function (mutations) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var mutation = _step.value;
            var removedNodes = mutation.removedNodes,
                addedNodes = mutation.addedNodes,
                type = mutation.type,
                attributeName = mutation.attributeName;

            // Determine relevant root DOM node.

            var rootNode = removedNodes[0] || addedNodes[0] || mutation.target;

            // If the mutation has a rootNode, the root node is a normal HTML
            // element (it has a hasAttribute property), and it's either not a
            // attribute mutation or the attribute is whitelisted, register
            // the qualifying rootNode and/or child nodes.
            var isWhitelisted = attributes.indexOf(attributeName) !== -1;
            var isAllowed = type !== 'attributes' || isWhitelisted;
            if (rootNode && rootNode.hasAttribute && isAllowed) {
              // Collect all form field child nodes.
              var nodes = [].concat(toConsumableArray(rootNode.querySelectorAll(fieldTags)));

              // If root node is a form field, add it to the node list.
              if (fieldTags.indexOf(rootNode.tagName.toLowerCase()) !== -1) {
                nodes.push(rootNode);
              }

              // If it's a childList mutation, determine if it's removing or
              // adding nodes.
              if (removedNodes && removedNodes.length) {
                type = 'removed';
              } else if (addedNodes && addedNodes.length) {
                type = 'added';
              }

              // Add or remove fields from the VueForm instance.
              _this2.registerFieldElements(nodes, type);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });

      // Configure the form MutationObserver to watch for all mustations on
      // element attributes and childNodes.
      var options = { attributes: true, subtree: true, childList: true };
      this.observer.observe(el, options);
    }

    // TODO doc
    /**
     * completeValidtion - description
     *
     * @param  {type} evt description
     * @return {type}     description
     */

  }, {
    key: 'completeValidtion',
    value: function completeValidtion(evt) {
      var _this3 = this;

      return new Promise(function (resolve) {
        var update = function update(id, resolve, hasCustomValidatorResult, result) {
          if (hasCustomValidatorResult) {
            _this3.setCustomValidity(id, result);
          }
          _this3.updateFormValidity(id);
          resolve();
        };
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          var _loop = function _loop() {
            var id = _step2.value;

            if (id) {
              var customValidator = _this3.customValidators[id];
              if (customValidator) {
                var response = customValidator(evt);
                if (response && response.then) {
                  response.then(function (result) {
                    return update(id, resolve, true, result);
                  });
                } else {
                  update(id, resolve, true, response);
                }
              } else {
                update(id, resolve);
              }
            }
          };

          for (var _iterator2 = getIds(evt.target)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            _loop();
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      });
    }

    /**
     * addEventListener - Adds an event listener on the given type so that the
     * elements validity state can be updated within the VueForm instance.
     *
     * @param  {HTMLElement} el The element to add the event listener.
     * @param  {String}      eventType The event type. i.e. 'change' or 'input'.
     */

  }, {
    key: 'addEventListener',
    value: function addEventListener(el, eventType) {
      var _this4 = this;

      el.addEventListener(eventType, function (evt) {
        // setTimeout necessary here to keep webkit/ie in sync.
        setTimeout(function () {
          var id = evt.target.getAttribute('id');
          var name = evt.target.getAttribute('name');
          if (id) {
            Object.assign(_this4.$cache.fields[id], extractValidity(evt.target));
          }
          if (name) {
            _this4.updateNamedValidity(evt.target);
          }
          _this4.completeValidtion(evt).then(function () {
            return _this4.updateState();
          });
        }, 0);
      });
    }

    /**
     * registerFieldElements - description
     *
     * @param  {type} nodes description
     * @param  {type} type  description
     * @return {type}       description
     */

  }, {
    key: 'registerFieldElements',
    value: function registerFieldElements(nodes, type) {
      var _this5 = this;

      var promises = [];

      // TODO comment
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        var _loop2 = function _loop2() {
          var node = _step3.value;

          var id = node.getAttribute('id');
          var name = node.getAttribute('name');
          var notIgnoredId = _this5.ignoredFields.indexOf(id) === -1;
          var notIgnoredName = _this5.ignoredFields.indexOf(name) === -1;

          if (notIgnoredId && notIgnoredName) {
            (function () {
              var $cache = _this5.$cache;

              var hasIdField = id && $cache.fields[id];
              var hasNameField = name && $cache.fields[name];

              // TODO comment
              if (type === 'added') {
                if (id) {
                  // Create the field object and extract its validity state.
                  $cache.fields[id] = createField(node);

                  // Add wasFocused class to element when focus event is triggered.
                  node.addEventListener('focus', function (_ref) {
                    var target = _ref.target;

                    $cache.fields[id].wasFocused = true;
                    target.classList.add(_this5.wasFocusedClass);
                    _this5.updateState();
                  });
                }

                // On change or input events, update the field and form validity
                // state.
                var inputType = node.getAttribute('type');
                var isCheckable = ['radio', 'checkbox'].indexOf(inputType) !== -1;
                var isSelect = node.tagName.toLowerCase() === 'select';
                var eventType = isSelect || isCheckable ? 'change' : 'input';
                _this5.addEventListener(node, eventType);
              } else if (hasIdField && type === 'attributes') {
                // Update the fields validity state because it may have
                // changed due to an updated attribute on its element.
                Object.assign($cache.fields[id], extractValidity(node));
              } else if ((hasIdField || hasNameField) && type === 'removed') {
                // If the field has been removed, set it to a new empty field
                // so that VueForm will not consider it invalid.
                $cache.fields[id || name] = createField();
              }

              // TODO comment
              if (name) {
                _this5.updateNamedValidity(node);
              }

              promises.push(_this5.completeValidtion({ target: node }));
            })();
          }
        };

        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          _loop2();
        }

        // TODO comment
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      Promise.all(promises).then(function () {
        return _this5.updateState();
      });
    }

    // TODO doc
    /**
     * get - description
     *
     * @param  {type} id description
     * @return {type}    description
     */

  }, {
    key: 'get',
    value: function get(id) {
      if (!this.state.fields[id]) {
        this.state.fields[id] = createField();
      }
      return this.state.fields[id];
    }

    /**
     * setCustomValidity - A wrapper for HTML5s setCustomValidity function so
     * that the end user can trigger a custom error without an error message,
     * the custom error message is accessible through the form object, and the
     * overall form validity is updated.
     *
     * @param {string}          id      The identifier for the field you wish to
     *                                  set the validity for.
     * @param {boolean|string}  invalid Whether the field is invalid (true), or
     *                                  not (false), or the custom error message
     *                                  for an invalid field.
     */

  }, {
    key: 'setCustomValidity',
    value: function setCustomValidity(id, invalid) {
      var $cache = this.$cache;

      if ($cache.fields[id]) {
        var isBoolean = typeof invalid === 'boolean';
        var isString = typeof invalid === 'string';
        var isNonEmptyString = isString && invalid.length > 0;
        if (invalid && (isBoolean || isNonEmptyString)) {
          if (isNonEmptyString) {
            $cache.fields[id].customMessage = invalid;
          } else {
            invalid = 'Error';
          }
        } else {
          $cache.fields[id].customMessage = null;
          invalid = '';
        }
        if ($cache.fields[id].el) {
          var el = $cache.fields[id].el;
          el.setCustomValidity(invalid);
          Object.assign($cache.fields[id], extractValidity(el));
        } else {
          $cache.fields[id].customError = invalid !== '';
          $cache.fields[id].valid = $cache.fields[id].valid && invalid === '';
        }
      }
    }

    /**
     * updateFormValidity - Updates the overall validity of the form based on
     * the existing validity state of its fields and the updated validity state
     * of the given field.
     *
     * @param {string} id The identifier for the field whose validity state has
     *                    updated and has consequently triggered the update of
     *                    the overall forms validity.
     */

  }, {
    key: 'updateFormValidity',
    value: function updateFormValidity(id) {
      var index = this.$cache.invalidFields.indexOf(id);
      var field = this.$cache.fields[id];
      var valid = field && (field.valid || field.valid === undefined);
      if (valid && index !== -1) {
        this.$cache.invalidFields.splice(index, 1);
        if (this.$cache.invalidFields.length === 0) {
          this.$cache.isValid = true;
          this.$cache.isInvalid = false;
        }
      } else if (!valid && index === -1) {
        this.$cache.isValid = false;
        this.$cache.isInvalid = true;
        this.$cache.invalidFields.push(id);
      }
    }

    /**
     * $updateNamedValidity - For the use case of requiring a value for a set
     * of checkboxes or radio buttons with the same name, VueForm provides the
     * validity state of the overall group using the name as the identifier.
     * This function updates this validity state.
     *
     * @param {HTMLElement} el  The DOM element that may trigger an update to
     *                          the validity of the named group.
     */

  }, {
    key: 'updateNamedValidity',
    value: function updateNamedValidity(el) {
      var name = el.getAttribute('name');
      var fields = this.$cache.fields;

      if (name && (this.requiredGroups.indexOf(name) !== -1 || fields[name])) {
        // Set the validity state of the named group.
        var valueMissing = this.getNamedValueMissing(name);
        var validity = { valueMissing: valueMissing, valid: !valueMissing };
        if (valueMissing === undefined) {
          validity.valid = undefined;
        }
        fields[name] = Object.assign({}, fields[name], validity);
      }
    }

    /**
     * getNamedValueMissing -
     *
     * @param  {type} name description
     * @return {type}      description
     */

  }, {
    key: 'getNamedValueMissing',
    value: function getNamedValueMissing(name) {
      var elements = [].concat(toConsumableArray(this.el.querySelectorAll('[name=' + name + ']')));
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = elements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var el = _step4.value;

          var isCheckable = ['radio', 'checkbox'].indexOf(el.type) !== -1;
          if (isCheckable && el.checked || !isCheckable && el.value) {
            return false;
          } else if (elements.indexOf(el) === elements.length - 1) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return undefined;
    }
  }], [{
    key: 'install',
    value: function install(Vue) {
      // A function added to the Vue object to allow end users to create a
      // new VueForm instance without having to directly import VueForm.
      Vue.prototype.$newVueForm = function (options) {
        return new VueForm(options);
      };

      /**
       * inserted - Called when the form element containing the v-form directive
       * is first inserted into the document and is used to set up the VueForm
       * instance with the form element.
       *
       * @param  {HTMLElement} el      The form element containing the v-form
       *                               directive.
       * @param  {Object}      context The context object associated with the
       *                               inserted directive event. Contains the
       *                               VueForm instance that is passed to the
       *                               v-form directive. i.e. v-form="myForm".
       */
      function inserted(el, context) {
        var formInstance = context.value;
        if (formInstance instanceof VueForm && !formInstance.el) {
          formInstance.registerFormElement(el, Vue);
        }
      }

      // Stop the forms MutationObserver instance from receiving notifications
      // of DOM mutations when the directive is unbound from the element. Not
      // sure if this cleanup is really necessary, but better safe than sorry I
      // guess.
      var unbind = function unbind(el, context) {
        var formInstance = context.value;
        if (formInstance instanceof VueForm && formInstance.observer) {
          formInstance.observer.disconnect();
        }
      };

      // Register the v-form directive.
      Vue.directive('form', { inserted: inserted, componentUpdated: inserted, unbind: unbind });

      // Register the v-custom-validator directive.
      Vue.directive('custom-validator', function (el, context) {
        var _context$value = slicedToArray(context.value, 2),
            formInstance = _context$value[0],
            customValidator = _context$value[1];

        if (formInstance instanceof VueForm) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = getIds(el)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _id = _step5.value;

              if (_id) {
                formInstance.customValidators[_id] = customValidator;
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      });
    }
  }]);
  return VueForm;
}();

return VueForm;

})));
